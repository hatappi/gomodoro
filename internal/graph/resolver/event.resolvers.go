package resolver

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"

	"github.com/99designs/gqlgen/graphql/handler/transport"
	"github.com/vektah/gqlparser/v2/gqlerror"

	"github.com/hatappi/gomodoro/internal/core/event"
	"github.com/hatappi/gomodoro/internal/graph/conv"
	"github.com/hatappi/gomodoro/internal/graph/model"
)

// EventReceived is the resolver for the eventReceived field.
func (r *subscriptionResolver) EventReceived(ctx context.Context, input model.EventReceivedInput) (<-chan *model.Event, error) {
	eventTypes, err := conv.GetEventTypesFromInput(input)
	if err != nil {
		return nil, err
	}

	busCh, unsubscribe := r.EventBus.SubscribeChannel(eventTypes)
	outCh := make(chan *model.Event)

	go func() {
		defer close(outCh)
		defer unsubscribe()

		for {
			select {
			case <-ctx.Done():
				return
			case e, ok := <-busCh:
				if !ok {
					return
				}

				switch evt := e.(type) {
				case event.PomodoroEvent:
					ev, err := conv.ConvertPomodoroEventToModelEvent(evt)
					if err != nil {
						transport.AddSubscriptionError(ctx, gqlerror.Errorf("failed to convert pomodoro event: %w", err))
						return
					}

					outCh <- ev
				case event.TaskEvent:
					ev, err := conv.ConvertTaskEventToModelEvent(evt)
					if err != nil {
						transport.AddSubscriptionError(ctx, gqlerror.Errorf("failed to convert task event: %w", err))
						return
					}

					outCh <- ev
				default:
					transport.AddSubscriptionError(ctx, gqlerror.Errorf("unknown event type: %T", evt))
				}
			}
		}
	}()

	return outCh, nil
}
